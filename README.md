# Bakery Production Planner API

API-сервис для оптимизации производственного плана в пекарне. Сервис принимает список заказов на продукцию и возвращает оптимальную последовательность их производства для минимизации общего времени выполнения (makespan).

Решение основано на решении задачи Job Shop Scheduling с использованием библиотеки **Google OR-Tools**. Для ускорения ответов на повторяющиеся запросы используется кэширование с помощью **Redis**.

## Особенности

*   **Оптимизация производства**: Строит оптимальный график, учитывая технологические этапы, доступное оборудование и критические временные промежутки между операциями.
*   **Гибкая настройка**: Все параметры (технологические карты, количество оборудования, время ожидания) вынесены в начало скрипта для легкой кастомизации.
*   **Кэширование**: Идентичные запросы обрабатываются мгновенно благодаря кэшу в Redis, что значительно снижает нагрузку на сервер и время отклика.
*   **Простое API**: RESTful-эндпоинт для интеграции с другими системами (например, с 1С или фронтенд-приложениями).

## Технологический стек

*   **Python 3**: Язык программирования.
*   **Flask**: Микрофреймворк для создания API.
*   **Google OR-Tools**: Библиотека для решения комбинаторных задач оптимизации.
*   **Redis**: In-memory хранилище для кэширования результатов.
*   **Docker**: Для простого развертывания Redis.

## Начало работы

### Требования

*   Python 3.8+
*   Docker и Docker Compose (рекомендуется)
*   Git

### 1. Клонирование репозитория

```bash
git clone <URL_вашего_репозитория>
cd <название_папки_проекта>
```

### 2. Установка зависимостей

Создайте и активируйте виртуальное окружение:

```bash
python -m venv venv
source venv/bin/activate  # Для Windows: venv\Scripts\activate
```

Установите необходимые Python-библиотеки:

```bash
pip install -r requirements.txt
```

> **Примечание:** Если у вас нет файла `requirements.txt`, создайте его командой:
> `pip freeze > requirements.txt`
> Он должен содержать как минимум:
> ```
> Flask==3.0.3
> ortools==9.9.3963
> redis==5.0.4
> ```

### 3. Запуск Redis

Самый простой способ запустить Redis — использовать Docker. Выполните в терминале:

```bash
docker run --name bakery-redis -p 6379:6379 -d redis
```

Эта команда скачает и запустит контейнер Redis в фоновом режиме. Сервис будет доступен на порту `6379`.

### 4. Запуск API-сервиса

Теперь можно запустить основное Flask-приложение:

```bash
python optimizer-app.py
```

Вы должны увидеть сообщения об успешном подключении к Redis и о запуске сервера:

```
✅ Успешное подключение к Redis.
Сервер запущен на http://0.0.0.0:8080
Для остановки сервера нажмите CTRL+C
```

Сервис готов к приему запросов!

## Использование API

### Эндпоинт для сортировки заказов

*   **URL**: `/api/orders/sort`
*   **Метод**: `POST`
*   **Тело запроса (Body)**: Массив JSON-объектов, где каждый объект представляет один продукт в заказе.

**Формат объекта:**
*   `name` (string, required): Название продукта. Должно точно соответствовать названиям в `tech_map_data`.
*   `amount` (integer, required): Количество единиц продукта.

**Пример тела запроса (`application/json`):**

```json
[
    {
        "name": "Хлеб «Формовой»",
        "amount": 150
    },
    {
        "name": "Багет «Новый»",
        "amount": 200
    },
    {
        "name": "Булочка для гамбургера большая / с кунжутом",
        "amount": 300
    }
]
```

**Пример ответа (успешный, `200 OK`):**

Сервис вернет тот же массив, но с добавленным полем `sort_order`, указывающим на оптимальную очередность запуска производства. Список отсортирован по этому полю.

```json
[
    {
        "sort_order": 1,
        "name": "Хлеб «Формовой»",
        "amount": 150
    },
    {
        "sort_order": 2,
        "name": "Булочка для гамбургера большая / с кунжутом",
        "amount": 300
    },
    {
        "sort_order": 3,
        "name": "Багет «Новый»",
        "amount": 200
    }
]
```

Если для какого-то продукта не удалось рассчитать порядок (например, его нет в технологической карте), его `sort_order` будет `null`, и он окажется в конце списка.

**Пример ответа (ошибка, `500 Internal Server Error`):**

Если планировщик не может найти решение (например, из-за слишком жестких ограничений), будет возвращена ошибка.

```json
{
    "error": "Не удалось найти выполнимое расписание. Проверьте параметры или доступность оборудования."
}
```

### Эндпоинт для очистки кэша

Для принудительной очистки всего кэша расчетов можно использовать этот эндпоинт.

*   **URL**: `/api/cache/clear`
*   **Метод**: `POST`
*   **Тело запроса**: Пустое.

**Пример ответа (`200 OK`):**

```json
{
    "message": "Кэш успешно очищен. Удалено ключей: 5."
}
```

## Конфигурация

Все основные параметры производства находятся в файле `optimizer-app.py`:

*   `tech_map_data`: Словарь с технологическими картами для каждого продукта.
*   `machines_available`: Количество доступного оборудования для каждого этапа.
*   `BATCH_SIZE`: Стандартный размер одной партии (влияет на расчеты).
*   `MAX_WAIT_*_MIN`: Максимально допустимое время простоя между критическими этапами.
*   **Подключение к Redis**: Адрес и порт Redis настраиваются через переменные окружения `REDIS_HOST` и `REDIS_PORT` (по умолчанию `localhost:6379`).
